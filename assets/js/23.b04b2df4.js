(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{236:function(e,t,o){"use strict";o.r(t);var a=o(0),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"staking-and-council-node"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#staking-and-council-node"}},[e._v("#")]),e._v(" Staking and Council Node")]),e._v(" "),o("p",[e._v("Crypto.com Chain is based on Tendermint Core's consensus engine, it relies on a set of validators (Council Node) to participate in the proof of stake (PoS) consensus protocol, and they are responsible for committing new blocks in the blockchain.")]),e._v(" "),o("h2",{attrs:{id:"staked-state-account"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#staked-state-account"}},[e._v("#")]),e._v(" Staked state / Account")]),e._v(" "),o("p",[e._v("StakedState is a data structure that holds state about staking:")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v('pub struct StakedState {\n    pub nonce: Nonce,    /// "from" operations counter\n    pub bonded: Coin,    /// bonded amount used to determine voting power\n    pub unbonded: Coin,    /// amount unbonded for future withdrawal\n    pub unbonded_from: Timespec,    /// time when unbonded amount can be withdrawn\n    pub address: StakedStateAddress,    /// the address used (to check transaction witness against)\n    pub validator: Option<Validator>,    /// validator metadata\n    pub last_slash: Option<SlashRecord>,    /// record the last slash only for query\n}\n')])])]),o("p",[e._v("TODO: should it have a minimum bonded amount?")]),e._v(" "),o("h2",{attrs:{id:"council-node"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#council-node"}},[e._v("#")]),e._v(" Council Node")]),e._v(" "),o("p",[e._v("Council Node is a data structure that holds state about a node responsible for transaction validation:")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("pub struct CouncilNode {\n    pub name: ValidatorName,    /// validator name / moniker (just for reference / human use)\n    pub security_contact: ValidatorSecurityContact,    /// optional security@... email address\n    pub consensus_pubkey: TendermintValidatorPubKey,    /// Tendermint consensus validator-associated public key\n    /// X.509 credential payload for MLS (https://tools.ietf.org/html/draft-ietf-mls-protocol-09)\n    /// (expected that attestation payload will be a part of the cert extension, as done in TLS)\n    pub confidential_init: ConfidentialInit,\n}\n")])])]),o("h3",{attrs:{id:"effective-min-stake"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#effective-min-stake"}},[e._v("#")]),e._v(" EFFECTIVE_MIN_STAKE")]),e._v(" "),o("p",[e._v("Effective minimum stake ("),o("code",[e._v("EFFECTIVE_MIN_STAKE")]),e._v(") is defined as follows at any time:")]),e._v(" "),o("ol",[o("li",[e._v("if the number of validators has not reached "),o("code",[e._v("MAX_VALIDATORS")]),e._v(", it is "),o("code",[e._v("COUNCIL_NODE_MIN_STAKE")]),e._v(" (the network parameter)")]),e._v(" "),o("li",[e._v("if the number of validators has reached "),o("code",[e._v("MAX_VALIDATORS")]),e._v(", it is equal to the lowest bonded amount of the staked states of the current validators plus 1.0 Coin.")])]),e._v(" "),o("h3",{attrs:{id:"joining-the-network"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#joining-the-network"}},[e._v("#")]),e._v(" Joining the network")]),e._v(" "),o("p",[e._v("Anyone who wishes to become a council node can submit a NodeJoinTx; this transaction is considered to be valid as long as:")]),e._v(" "),o("ol",[o("li",[e._v("The associated staking account has "),o("code",[e._v("bonded")]),e._v(" amount >= "),o("code",[e._v("EFFECTIVE_MIN_STAKE")]),e._v(" and is not "),o("a",{attrs:{href:"#punishments"}},[e._v("punished")]),e._v(";")]),e._v(" "),o("li",[e._v("There is no other validator with the same "),o("code",[e._v("staking_address")]),e._v(" or the "),o("code",[e._v("consensus_pubkey")])])]),e._v(" "),o("h3",{attrs:{id:"leaving-the-network"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#leaving-the-network"}},[e._v("#")]),e._v(" Leaving the network")]),e._v(" "),o("p",[e._v("Anyone who wishes to leave the network, provided their associated staked state does not have any punishments, can submit UnbondStakeTx with the amount that will reduce the "),o("code",[e._v("bonded")]),e._v(" amount to be lower than "),o("code",[e._v("COUNCIL_NODE_MIN_STAKE")]),e._v(".")]),e._v(" "),o("h4",{attrs:{id:"voting-power-and-proposer-selection"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#voting-power-and-proposer-selection"}},[e._v("#")]),e._v(" Voting power and proposer selection")]),e._v(" "),o("p",[e._v("At the beginning of each round, a council node will be chosen deterministically to be the block proposer.")]),e._v(" "),o("p",[e._v("The chance of being a proposer is directly proportional to their "),o("em",[e._v("voting power")]),e._v(" at that time, which, in general, is equal to the "),o("code",[e._v("bonded")]),e._v(" amount (rounded to the whole unit) in the associated staking address of the council node.")]),e._v(" "),o("p",[e._v("The top "),o("code",[e._v("MAX_VALIDATORS")]),e._v(" with the most "),o("code",[e._v("bonded")]),e._v(" amount would put to the "),o("em",[e._v("active")]),e._v(" validator set in "),o("code",[e._v("END_BLOCK")]),e._v(". If a validator's "),o("code",[e._v("bonded")]),e._v(" amount is below the top "),o("code",[e._v("MAX_VALIDATORS")]),e._v(", It will be considered as "),o("em",[e._v("non-active")]),e._v(" and would not be able to take part in the consensus. For example,")]),e._v(" "),o("ul",[o("li",[o("p",[e._v("If the number of "),o("em",[e._v("active")]),e._v(" validators < "),o("code",[e._v("MAX_VALIDATORS")]),e._v(":")]),e._v(" "),o("table",[o("thead",[o("tr",[o("th"),e._v(" "),o("th",[o("code",[e._v("bonded")]),e._v(" amount < "),o("code",[e._v("COUNCIL_NODE_MIN_STAKE")])]),e._v(" "),o("th",[o("code",[e._v("bonded")]),e._v(" amount => "),o("code",[e._v("COUNCIL_NODE_MIN_STAKE")])])])]),e._v(" "),o("tbody",[o("tr",[o("td",[e._v("Validator's voting power")]),e._v(" "),o("td",[e._v("Set to 0")]),e._v(" "),o("td",[e._v("Set to the "),o("code",[e._v("bonded")]),e._v(" amount")])])])])]),e._v(" "),o("li",[o("p",[e._v("On the other hand, If the number of "),o("em",[e._v("active")]),e._v(" validators = "),o("code",[e._v("MAX_VALIDATORS")]),e._v(":")]),e._v(" "),o("table",[o("thead",[o("tr",[o("th"),e._v(" "),o("th",[o("code",[e._v("bonded")]),e._v(" amount is below the top "),o("code",[e._v("MAX_VALIDATORS")])]),e._v(" "),o("th",[e._v("Otherwise")])])]),e._v(" "),o("tbody",[o("tr",[o("td",[e._v("Validator's voting power")]),e._v(" "),o("td",[e._v("Set to 0")]),e._v(" "),o("td",[e._v("Set to the "),o("code",[e._v("bonded")]),e._v(" amount")])])])])])]),e._v(" "),o("h3",{attrs:{id:"removed-validators-council-nodes"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#removed-validators-council-nodes"}},[e._v("#")]),e._v(" Removed validators / council nodes")]),e._v(" "),o("p",[e._v("A Validator is removed when its voting power is set to 0.\nThis can happen in the following scenarios:")]),e._v(" "),o("ol",[o("li",[e._v("The Validator is being punished for infraction(s).")]),e._v(" "),o("li",[e._v("Its operator submitted UnbondStakeTx with sufficient stake to leave the network.")]),e._v(" "),o("li",[e._v("When the "),o("code",[e._v("bonded")]),e._v(" amount <= "),o("code",[e._v("EFFECTIVE_MIN_STAKE")])])]),e._v(" "),o("p",[e._v("When this happens, the following metadata is cleaned up as follows:")]),e._v(" "),o("ul",[o("li",[e._v("its associated reward tracking-related data is cleared:\n"),o("ul",[o("li",[e._v("(a) immediately ("),o("em",[e._v("if the validator is being punished")]),e._v(")")]),e._v(" "),o("li",[e._v("(b) in the block that triggers next reward distribution ("),o("em",[e._v("otherwise")]),e._v(")")])])]),e._v(" "),o("li",[e._v("its liveness tracking information is cleared in the block when this occurs")]),e._v(" "),o("li",[e._v("its slashing related information (mapping Tendermint address / pubkey => staked state address) is scheduled to be cleared in a block after the current block time + "),o("code",[e._v("MAX_EVIDENCE_AGE")]),e._v(" ("),o("code",[e._v("SLASH_MAP_DELETE")]),e._v(")")])]),e._v(" "),o("p",[e._v("Note this inequality must be checked in network parameters: UNBOND_PERIOD >= JAIL_DURATION >= MAX_EVIDENCE_AGE")]),e._v(" "),o("p",[e._v("If the validator wishes to re-join the validator set, they can (unjail if necessary and) submit a NodeJoinTx (see the Joining the Network section).")]),e._v(" "),o("p",[e._v("If the NodeJoinTx transaction is valid AND this happens before "),o("code",[e._v("SLASH_MAP_DELETE")]),e._v(' AND the consensus pubkey (or associated Tendermint address) from NodeJoinTx transaction is the same, the previous slashing information is preserved (i.e. the "delete schedule" is cancelled).')]),e._v(" "),o("p",[e._v("If the NodeJoinTx transaction is valid AND this happens before next reward distribution AND the consensus pubkey from NodeJoinTx transaction is different, the associated staked state is then rewarded for interactions with both consensus pubkeys (as reward tracking is per staked state).")]),e._v(" "),o("h3",{attrs:{id:"validators-council-nodes"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#validators-council-nodes"}},[e._v("#")]),e._v(" Validators / Council Nodes")]),e._v(" "),o("p",[e._v("Each "),o("code",[e._v("BeginBlock")]),e._v(" contains two fields that will determine penalties:")]),e._v(" "),o("ul",[o("li",[e._v("LastCommitInfo: this contains information which validators signed the last block")]),e._v(" "),o("li",[e._v("ByzantineValidators: evidence of validators that acted maliciously")])]),e._v(" "),o("p",[e._v("Their processing is the following:")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("FIXME: this looks out of date?\n\nfor each evidence in ByzantineValidators:\n    if evidence.Timestamp >= BeginBlock.Timestamp - MAX_EVIDENCE_AGE:\n        account = (... get corresponding account ...)\n        if account.slashing_period.end is set and it's before BeginBlock.Timestamp:\n            account.slashing_period.slashed_ratio = max(account.slashing_period.slashed_ratio, BYZANTINE_SLASH_RATIO)\n        else:\n            if account.slashing_period.end is set and it's after BeginBlock.Timestamp:\n                END/COMMIT_BLOCK_STATE_UPDATE(deduct(slashing_period, account))\n\n            account.slashing_period = Some(SlashingPeriod(start = Some(BeginBlock.Timestamp),\n                end = Some(BeginBlock.Timestamp + SLASHING_PERIOD_DURATION, slashed_ratio = BYZANTINE_SLASH_RATIO)))\n            account.jailed_until = Some(BeginBlock.Timestamp + JAIL_DURATION)\n\n\nfor each signer in LastCommitInfo:\n    council_node = (... lookup by signer / tendermint validator key ...)\n    update(council_node, BLOCK_SIGNING_WINDOW)\n\nfor each council_node:\n    missed_blocks = get_missed_signed_blocks(council_node)\n    if missed_blocks / BLOCK_SIGNING_WINDOW >= MISSED_BLOCK_THRESHOLD:\n        account = (... lookup corresponding account ...)\n        if account.slashing_period.end is set and it's before BeginBlock.Timestamp:\n            account.slashing_period.slashed_ratio = max(account.slashing_period.slashed_ratio, LIVENESS_SLASH_RATIO)\n        else:\n            if account.slashing_period.end is set and it's after BeginBlock.Timestamp:\n                END/COMMIT_BLOCK_STATE_UPDATE(deduct(slashing_period, account))\n\n            account.slashing_period = Some(SlashingPeriod(start = Some(BeginBlock.Timestamp),\n                end = Some(BeginBlock.Timestamp + SLASHING_PERIOD_DURATION, slashed_ratio = LIVENESS_SLASH_RATIO)))\n            account.jailed_until = Some(BeginBlock.Timestamp + JAIL_DURATION)\n")])])]),o("h3",{attrs:{id:"global-state-app-hash"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#global-state-app-hash"}},[e._v("#")]),e._v(" “Global state” / APP_HASH")]),e._v(" "),o("p",[e._v("Tendermint expects a single compact value, "),o("code",[e._v("APP_HASH")]),e._v(", after each BlockCommit that represents the state of the application. In the early Chain prototype, this was constructed as a root of a Merkle tree from IDs of valid transactions.")]),e._v(" "),o("p",[e._v("In this staking scenario, some form of “chimeric ledger” needs to be employed, as staking-related functionality is represented with accounts. In Ethereum, "),o("a",{attrs:{href:"https://github.com/ethereum/wiki/wiki/Design-Rationale#merkle-patricia-trees",target:"_blank",rel:"noopener noreferrer"}},[e._v("Merkle Patricia Trees"),o("OutboundLink")],1),e._v(" are used: (The "),o("a",{attrs:{href:"https://github.com/tendermint/iavl",target:"_blank",rel:"noopener noreferrer"}},[e._v("alternative"),o("OutboundLink")],1),e._v(" in Tendermint: depends on the order of transactions though)")]),e._v(" "),o("p",[e._v("They could possibly be used to represent an UTXO set: https://medium.com/codechain/codechains-merkleized-utxo-set-c76c9376fd4f")]),e._v(" "),o("p",[e._v("The overall “global state” then consists of the following items:")]),e._v(" "),o("ul",[o("li",[e._v("UTXO set")]),e._v(" "),o("li",[e._v("Account")]),e._v(" "),o("li",[e._v("RewardsPool")]),e._v(" "),o("li",[e._v("CouncilNode")])]),e._v(" "),o("p",[e._v("So each component could possibly be represented as MPT and these MPTs would then be combined together to form a single "),o("code",[e._v("APP_HASH")]),e._v(".")]),e._v(" "),o("h3",{attrs:{id:"end-commit-block-state-update"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#end-commit-block-state-update"}},[e._v("#")]),e._v(" END/COMMIT_BLOCK_STATE_UPDATE")]),e._v(" "),o("p",[e._v("FIXME: scheduling slashing cleanup")]),e._v(" "),o("p",[e._v("Besides committing all the relevant changes and computing the resulting "),o("code",[e._v("APP_HASH")]),e._v(" in "),o("code",[e._v("BlockCommit")]),e._v("; for all changes in "),o("em",[e._v("Accounts")]),e._v(", the implementation needs to signal "),o("code",[e._v("ValidatorUpdate")]),e._v(" in "),o("code",[e._v("EndBlock")]),e._v(".")]),e._v(" "),o("p",[e._v("For example, when the number of "),o("em",[e._v("active validators")]),e._v(" is less then "),o("code",[e._v("MAX_VALIDATORS")]),e._v(":")]),e._v(" "),o("ul",[o("li",[o("p",[e._v("When the changes are relevant to the "),o("code",[e._v("bonded")]),e._v(" amount of the council node’s staking address and the validator is not jailed:")]),e._v(" "),o("ul",[o("li",[e._v("If the "),o("code",[e._v("bonded")]),e._v(" amount changes and < "),o("code",[e._v("COUNCIL_NODE_MIN_STAKE")]),e._v(", then the validator’s voting power should be set to 0;")]),e._v(" "),o("li",[e._v("If the "),o("code",[e._v("bonded")]),e._v(" amount changes and >= "),o("code",[e._v("COUNCIL_NODE_MIN_STAKE")]),e._v(", then the validator’s voting power should be set to that amount (rounded to the whole unit).")])])]),e._v(" "),o("li",[o("p",[e._v("When the changes are relevant to the jailing condition of the council node’s staking address:")]),e._v(" "),o("ul",[o("li",[o("p",[e._v("If the "),o("code",[e._v("jailed_until")]),e._v(" changes to "),o("code",[e._v("Some(...)")]),e._v(" (i.e. the node is being "),o("em",[e._v("jailed)")]),e._v(", then the validator’s power should be set to 0;")])]),e._v(" "),o("li",[o("p",[e._v("If the "),o("code",[e._v("jailed_until")]),e._v(" changes to "),o("code",[e._v("None")]),e._v(" (i.e. the node was "),o("em",[e._v("un-jailed")]),e._v(") and "),o("code",[e._v("bonded")]),e._v(" amount >= "),o("code",[e._v("COUNCIL_NODE_MIN_STAKE")]),e._v(", then the validator’s power should be set to the "),o("code",[e._v("bonded")]),e._v(" amount (rounded to the whole unit).")]),e._v(" "),o("p",[e._v("It can be summarized in the following table:")]),e._v(" "),o("table",[o("thead",[o("tr",[o("th"),e._v(" "),o("th",[o("code",[e._v("bonded")]),e._v(" <  "),o("code",[e._v("COUNCIL_NODE_MIN_STAKE")])]),e._v(" "),o("th",[o("code",[e._v("bonded")]),e._v(" >=  "),o("code",[e._v("COUNCIL_NODE_MIN_STAKE")]),e._v(" but "),o("em",[e._v("Jailed")])]),e._v(" "),o("th",[o("code",[e._v("bonded")]),e._v(" >=  "),o("code",[e._v("COUNCIL_NODE_MIN_STAKE")]),e._v(" and "),o("em",[e._v("NOT jailed")])])])]),e._v(" "),o("tbody",[o("tr",[o("td",[e._v("Validator's voting power")]),e._v(" "),o("td",[e._v("Set to 0")]),e._v(" "),o("td",[e._v("Set to 0")]),e._v(" "),o("td",[e._v("Set to the "),o("code",[e._v("bonded")]),e._v(" amount")])])])])])])])]),e._v(" "),o("p",[e._v("On the other hand, If the number of the current "),o("em",[e._v("active")]),e._v(" validators is equal to "),o("code",[e._v("MAX_VALIDATORS")]),e._v(", the validator's voting power will also be depended on whether its "),o("code",[e._v("bonded")]),e._v(" amount is at the top "),o("code",[e._v("MAX_VALIDATORS")]),e._v(", please refer to the "),o("a",{attrs:{href:"#voting-power-and-proposer-selection"}},[e._v("previous section")])]),e._v(" "),o("h3",{attrs:{id:"initchain"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#initchain"}},[e._v("#")]),e._v(" InitChain")]),e._v(" "),o("p",[e._v("The initial prototype’s configuration will need to contain the following elements:")]),e._v(" "),o("ul",[o("li",[o("RouterLink",{attrs:{to:"/getting-started/network-parameters.html"}},[e._v("Network parameters")])],1),e._v(" "),o("li",[e._v("ERC20 snapshot state / holder mapping "),o("code",[e._v("initial_holders")]),e._v(":\n"),o("code",[e._v("Vec<(address: RedeemAddress, is_contract: bool, amount: Coin)>")]),e._v(" (or "),o("code",[e._v("Map<RedeemAddress, (bool, Coin)>")]),e._v(")")]),e._v(" "),o("li",[e._v("Network long-term incentive address: "),o("code",[e._v("nlt_address")])]),e._v(" "),o("li",[e._v("Secondary distribution and launch incentive addresses: "),o("code",[e._v("dist_address1")]),e._v(", "),o("code",[e._v("dist_address2")])]),e._v(" "),o("li",[e._v("Initial validators: "),o("code",[e._v("Vec<CouncilNode>")])]),e._v(" "),o("li",[e._v("Bootstrap nodes / initially bonded: "),o("code",[e._v("Vec<RedeemAddress>")])])]),e._v(" "),o("p",[e._v("The validation of the configuration is the following:")]),e._v(" "),o("ol",[o("li",[e._v("validate parameters format (e.g. CUSTOMER_ACQUIRER_SHARE + MERCHANT_ACQUIRER_SHARE + COUNCIL_NODE_SHARE = 1.0)")]),e._v(" "),o("li",[e._v("check that sum of amounts in "),o("code",[e._v("initial_holders")]),e._v(" == MAX_COIN (network constant)")]),e._v(" "),o("li",[e._v("check there are no duplicate addresses (if Vec) in "),o("code",[e._v("initial_holders")])]),e._v(" "),o("li",[e._v("for each "),o("code",[e._v("council_node")]),e._v(" in "),o("code",[e._v("Vec<CouncilNode>")]),e._v(": check "),o("code",[e._v("staking_address")]),e._v(" is in "),o("code",[e._v("initial_holders")]),e._v(" and the amount >= "),o("code",[e._v("COUNCIL_NODE_MIN_STAKE")])]),e._v(" "),o("li",[e._v("for each "),o("code",[e._v("address")]),e._v(" in initially bonded "),o("code",[e._v("Vec<RedeemAddress>")]),e._v(": check "),o("code",[e._v("address")]),e._v(" is "),o("code",[e._v("initial_holders")]),e._v(" and the amount >= "),o("code",[e._v("COMMUNITY_NODE_MIN_STAKE")])]),e._v(" "),o("li",[e._v("size(Validators in InitChainRequest) == size("),o("code",[e._v("Vec<CouncilNode>")]),e._v(") and for every CouncilNode, its "),o("code",[e._v("consensus_pubkey")]),e._v(" appears in Validators and power in Validators corresponds to staking address’ amount")])]),e._v(" "),o("p",[e._v("If valid, the genesis state is then initialized as follows:")]),e._v(" "),o("ol",[o("li",[e._v("initialize RewardsPool’s amount with amounts corresponding to: "),o("code",[e._v("nlt_address")]),e._v(" + "),o("code",[e._v("dist_address1")]),e._v(" + "),o("code",[e._v("dist_address2")])]),e._v(" "),o("li",[e._v("for every council node, create a "),o("code",[e._v("CouncilNode")]),e._v(" structure")]),e._v(" "),o("li",[e._v("for every council node’s staking address and every address in initially bonded: create "),o("code",[e._v("Account")]),e._v(" where all of the corresponding amount is set as "),o("code",[e._v("bonded")])]),e._v(" "),o("li",[e._v("for every address in "),o("code",[e._v("initial_holders")]),e._v(" except for "),o("code",[e._v("nlt_address")]),e._v(", "),o("code",[e._v("dist_address1")]),e._v(", "),o("code",[e._v("dist_address2")]),e._v(", council nodes’ staking addresses, initially bonded addresses: if "),o("code",[e._v("is_contract")]),e._v(" then add the amount to RewardsPool else create "),o("code",[e._v("Account")]),e._v(" where the amount is all in "),o("code",[e._v("unbonded")]),e._v(" and "),o("code",[e._v("unbonded_from")]),e._v(" is set to genesis block’s time (in InitChain)")])])])}),[],!1,null,null,null);t.default=n.exports}}]);