(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{397:function(t,e,a){"use strict";a.r(e);var s=a(42),n=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"transaction-data-bootstrapping-enclave-details"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#transaction-data-bootstrapping-enclave-details"}},[t._v("#")]),t._v(" Transaction Data Bootstrapping Enclave details")]),t._v(" "),a("p",[t._v("Transaction Validation Enclave (TVE):")]),t._v(" "),a("ul",[a("li",[t._v("responsible for validating Enclave tx types;")]),t._v(" "),a("li",[t._v("holds current tx obfuscation key;")]),t._v(" "),a("li",[t._v("reacts to "),a("em",[t._v("immediate")]),t._v(" requests (chain-abci, i.e. potentially uncommitted or invalid transaction; encryption requests from tx-query enclave)")]),t._v(" "),a("li",[t._v("chain-abci directly talks to it during (consensus) state-machine execution")])]),t._v(" "),a("p",[t._v("Transaction Data Bootstrapping Enclave (TDBE):")]),t._v(" "),a("ul",[a("li",[t._v("responsible for generating MLSHandshake tx types;")]),t._v(" "),a("li",[t._v("fetches old transaction data payloads;")]),t._v(" "),a("li",[t._v("prerequisite for a node administrator to submit a node join tx request or construct genesis.json")]),t._v(" "),a("li",[t._v("reacts to "),a("em",[t._v("block-committed")]),t._v(" requests:\n"),a("ul",[a("li",[t._v("needs to run a Tendermint light client verification (TODO: trusted anchor injected as compile-time data?) and be connected to its Tendermint node RPC")]),t._v(" "),a("li",[t._v("chain-abci does not talk to it (it may invoke it during startup / for fetching old tx data, but can't talk to it during state-machine execution)")]),t._v(" "),a("li",[t._v('"knows" when it should generate MLSHandshake tx: 1) when in mid-time of keypackage expiration; 2) being "leftmost" node')]),t._v(" "),a("li",[t._v("based on valid block-committed requests, it should update its internal states, derive secrets and push tx obfuscation key to TVE")])])])]),t._v(" "),a("h2",{attrs:{id:"new-rejoining-node"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#new-rejoining-node"}},[t._v("#")]),t._v(" new/rejoining node")]),t._v(" "),a("p",[t._v("(for non-genesis specified ones)")]),t._v(" "),a("ul",[a("li",[t._v("submit council or community node join request TX")]),t._v(" "),a("li",[t._v("if valid, wait until CommitChangeTx is committed with Welcome payload")]),t._v(" "),a("li",[t._v('mark the block where this CommitChangeTx is committed as the "fetched up to" block\nand obtain old transaction data')])]),t._v(" "),a("p",[t._v("TODO: fetch keypackages/leaf nodes? https://github.com/mlswg/mls-protocol/issues/344")]),t._v(" "),a("h3",{attrs:{id:"obtaining-old-transaction-data"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#obtaining-old-transaction-data"}},[t._v("#")]),t._v(" Obtaining old transaction data")]),t._v(" "),a("p",[t._v('When a node is started up (before tendermint consensus syncing etc.), it should be provided\n"genesis-skip" (in the case it\'s one of nodes starting at genesis)\nor one or more connection strings\nthat would proxy to some public full node RPC.')]),t._v(" "),a("p",[t._v("Via the Tendermint light-client-verifying connection, it should obtain the list of\nneeded transaction IDs (of withdrawal and transfer transactions):")]),t._v(" "),a("ul",[a("li",[t._v("full node / historical querying: all IDs between its last processed block and the last block on the remote node")]),t._v(" "),a("li",[t._v('validator: new IDs in the "UTXO set diff" between its last processed block and the last block on the remote node\n(TODO: https://github.com/crypto-com/chain/issues/794 ; initial implementation here can start with just "all IDs" for both)')])]),t._v(" "),a("p",[t._v("From remote node RPC, it should also learn its TDBE connection details\nand then initiate enclave-to-enclave mutually attested TLS: TODO https://github.com/crypto-com/chain/issues/1549\nand fetch the needed transaction payloads and seal them for its host.")]),t._v(" "),a("p",[t._v("TODO: handling in abci -- options (probably start with option 1):")]),t._v(" "),a("ol",[a("li",[t._v('record the "fetched up to" block;\nreport to TM still the last processed block\nand run normal TM block-by-block syncing and skip tx-validation-enclave until the "fetched up to" block')]),t._v(" "),a("li",[t._v('TM 0.34+ -- run state-sync for jellyfish merkle / staking state https://docs.tendermint.com/master/spec/abci/apps.html#state-sync\nand resume from the "fetched up to" block?')])]),t._v(" "),a("h2",{attrs:{id:"sealing-recovering"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sealing-recovering"}},[t._v("#")]),t._v(" Sealing / recovering")]),t._v(" "),a("p",[t._v('on genesis or when the (add/update) request is committed,\nTDBE should seal its init key + credential + "trusted anchor" parts (app hash components, validator identities... block number)\nwith app hash (or some state fingerprint?) as AAD.')]),t._v(" "),a("p",[t._v("Restarted TDBE (that wasn't kicked out) starts off this state via the TM light client")]),t._v(" "),a("h2",{attrs:{id:"security-upgrades"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#security-upgrades"}},[t._v("#")]),t._v(" Security upgrades")]),t._v(" "),a("p",[t._v("TDBE/chain-abci should keep track of the highest "),a("code",[t._v("isv_svn")]),t._v(" observed\n(in a valid committed tx) and reject Add/Update proposals with a lower number.\nfor (old) data bootstrapping:")]),t._v(" "),a("ul",[a("li",[t._v("TDBE (server): reject all TLS connections with lower "),a("code",[t._v("isv_svn")]),t._v(" than the highest one")]),t._v(" "),a("li",[t._v("TDBE (client): keep track keypackage "),a("code",[t._v("isv_svn")]),t._v(" proportions (based on MLSHandshake messages);\n"),a("ul",[a("li",[t._v("if (highest "),a("code",[t._v("isv_svn")]),t._v(" count / lower "),a("code",[t._v("isv_svn")]),t._v(" count >= 2/3), reject all TLS connections with lower "),a("code",[t._v("isv_svn")]),t._v(" than the highest one")]),t._v(" "),a("li",[t._v("otherwise, tolerate fetching data from servers where "),a("code",[t._v("isv_svn")]),t._v(" == "),a("code",[t._v("the highest one - 1")])])])])]),t._v(" "),a("h3",{attrs:{id:"svn-verification-compilation-order"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#svn-verification-compilation-order"}},[t._v("#")]),t._v(" SVN verification + compilation order")]),t._v(" "),a("p",[t._v("Besides verifying "),a("code",[t._v("MRSIGNER")]),t._v(", ProductId, etc. is the same as in "),a("code",[t._v("Report::for_self()")]),t._v(", one should also verify:")]),t._v(" "),a("ul",[a("li",[t._v("TDBE: if (other party's "),a("code",[t._v("isv_svn")]),t._v(") == (my "),a("code",[t._v("isv_svn")]),t._v(" / in the report), check MRENCLAVE is the same")]),t._v(" "),a("li",[t._v("TVE: (incoming local connection's  "),a("code",[t._v("isv_svn")]),t._v(") == (my "),a("code",[t._v("isv_svn")]),t._v(") and MRENCLAVE is corresponding to compile-time encoded value of TQE or TDBE (depending on the expected connection type)")])]),t._v(" "),a("p",[t._v("NOTE: as TVE only expects local communication, it should expect "),a("code",[t._v("isv_svn")]),t._v(" to be exactly the same as its own\n(the node operator would update all binaries at once on its node).")]),t._v(" "),a("p",[t._v("This mandates the following compilation / signing order:")]),t._v(" "),a("ol",[a("li",[t._v("TDBE")]),t._v(" "),a("li",[t._v("TQE")]),t._v(" "),a("li",[t._v("TVE: (provided TDBE's and TQE's MRENCLAVE values at compile-time)")])]),t._v(" "),a("h2",{attrs:{id:"obfuscation-key-rotation-via-message-layer-security-handshakes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#obfuscation-key-rotation-via-message-layer-security-handshakes"}},[t._v("#")]),t._v(" Obfuscation key rotation via Message Layer Security handshakes")]),t._v(" "),a("h3",{attrs:{id:"data-type-modifications"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#data-type-modifications"}},[t._v("#")]),t._v(" data type modifications")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" StakedState "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    address"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" StakedStateAddress"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    nonce"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" u64"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    bonded"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Coin"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    unbonded"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Coin"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    unbonded_from"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Timespec"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    node_details"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Option"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("NodeDetails"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("enum")]),t._v(" NodeDetails "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Council")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Validator"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Community")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("FullNode"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" FullNode "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    council_node"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" CommunityNode"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    jailed_until"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Option"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Timespec"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// TODO: should there be jailing? for invalid handshake tx submission?")]),t._v("\n    inactive_time"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Option"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Timespec"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// TODO: when missing submitting handshake tx? should validator have 2 "inactive times"?')]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pub")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" CommunityNode "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pub")]),t._v(" name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/// name / moniker (just for reference / human use)")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pub")]),t._v(" security_contact"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Contact"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/// optional security@... email address")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pub")]),t._v(" confidential_init"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" ConfidentialInit"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// contains the keypackage")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h3",{attrs:{id:"extra-network-params"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#extra-network-params"}},[t._v("#")]),t._v(" extra network params")]),t._v(" "),a("ul",[a("li",[t._v("community node minimal required stake")]),t._v(" "),a("li",[t._v("mls handshake commit timeout")]),t._v(" "),a("li",[t._v("mls handshake message NACK timeout")]),t._v(" "),a("li",[t._v("slash rate for invalid commits?")]),t._v(" "),a("li",[t._v("keypackage expiration time (as there are consensus-related rules --\ne.g. when to remove nodes with expired keypackages whose TDBE failed to submit update in time;\nwhen/how often update can be submitted -- it probably should be a consensus parameter)")])]),t._v(" "),a("h3",{attrs:{id:"genesis-json-creation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#genesis-json-creation"}},[t._v("#")]),t._v(" genesis.json creation")]),t._v(" "),a("p",[t._v("The genesis generation ceremony needs to happen in several steps:")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("Keypackage-independent parameters are exchanged/specified as compile-time parameters (for the light client trusted anchor basis)")])]),t._v(" "),a("li",[a("p",[t._v("enclave code is compiled with these parameters and signed on by the production key")])]),t._v(" "),a("li",[a("p",[t._v("administrators of nodes participating from genesis obtain and verify the signed binaries and use them to generate their keypackages")])]),t._v(" "),a("li",[a("p",[t._v("they exchange keypackages")])]),t._v(" "),a("li",[a("p",[t._v("leftmost / first validator's node administrator is responsible for generating the first MLSHandshake CommitChange that's included in genesis.json\nand generating and distributing genesis.json (that's verified by other parties)")])])]),t._v(" "),a("h3",{attrs:{id:"extra-tx-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#extra-tx-types"}},[t._v("#")]),t._v(" extra TX types")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Enclave\n  ...\nPublic\n  ...\n  NodeJoin\nMLSHandshake\n  CommitChange\n  SelfUpdateProposal\n  MsgNack\n")])])]),a("p",[t._v("NodeJoin is extended that instead of taking "),a("code",[t._v("CouncilNode")]),t._v(", it'd take "),a("code",[t._v("NodeMetadata")]),t._v(" which is enum\nwith council node and community node variants.\nTODO: extra rules for CouncilNode -> CommunityNode (needs to unbond / become inactive first?)")]),t._v(" "),a("h4",{attrs:{id:"handshake-transactions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#handshake-transactions"}},[t._v("#")]),t._v(" Handshake transactions")]),t._v(" "),a("p",[t._v("internal "),a("code",[t._v("Vec<u8>")]),t._v(" payloads are expected to be encoded in the TLS standard binary encodings\n(TODO:\n"),a("a",{attrs:{href:"https://github.com/mlswg/mls-architecture/blob/master/draft-ietf-mls-architecture.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("the draft MLS architecture doc"),a("OutboundLink")],1),t._v(":")]),t._v(" "),a("blockquote",[a("p",[t._v("In addition, it does not specify a complete wire encoding, but rather a set of abstract data structures which can then be mapped onto a variety of concrete encodings, such as TLS RFC8446, CBOR RFC7049, and JSON RFC7159.")])]),t._v(" "),a("p",[t._v("Besides X.509 (to reuse TLS RA stuff) identities in keypackages, we may potentially switch to SCALE to keep it simpler;\nTLS wire format is mainly interesting for test-vectors / unit tests, but the protocol draft is too in flux at the moment.\n).")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pub")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" CommitChangeTx "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    messages"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Vec"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Vec"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("u8"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// MLSPlaintext -- any proposals (Add or Remove), the last one is assumed to be Commit")]),t._v("\n    welcome"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Option"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Vec"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("u8"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Welcome -- if there are any Add proposals, there should be a welcome with encrypted paths/epochs for new joiners")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pub")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" SelfUpdateProposal "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    proposal"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Vec"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("u8"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// MLSPlaintext -- Update")]),t._v("\n    commit"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Vec"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("u8"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// MLSPlaintext -- Commit")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pub")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" MsgNack "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    nack"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Vec"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("u8"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// msg ref + `zz` + DLEQ proof -- TBD: https://github.com/mlswg/mls-protocol/issues/21#issuecomment-455392023")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("(TODO: "),a("code",[t._v("CommitChangeTx")]),t._v(" / "),a("code",[t._v("SelfUpdateProposal")]),t._v(" may need to contain Schnorr NIZK of knowledge (RFC 8235)\nfor encrypted parts ("),a("code",[t._v("Welcome")]),t._v(", "),a("code",[t._v("DirectPathNode")]),t._v("...))")]),t._v(" "),a("h5",{attrs:{id:"tdbe-handling-generation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tdbe-handling-generation"}},[t._v("#")]),t._v(" TDBE handling / generation")]),t._v(" "),a("p",[t._v("TDBE runs as a standalone enclave which includes TM light client and reacts to information received from it.\nFor fetched transactions with MLS handshake messages, it should verify they are valid (i.e. their TXID is a leaf in the Merkle tree\nof valid transactions in a particular block).\nIt opens mutually attested TLS connection to tx-validation enclave (TVE) for pushing exported obfuscation keys.")]),t._v(" "),a("h6",{attrs:{id:"commits"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#commits"}},[t._v("#")]),t._v(" Commits")]),t._v(" "),a("p",[t._v("When a block is committed with nodejoin, unbond or punishment events (liveness/byzantine issues, bue also including expired keypackages),\nNode's TDBE corresponding to the leftmost non-empty leaf should generate and broadcast "),a("code",[t._v("CommitChangeTx")]),t._v(" with proposals reflecting the triggering block's change (Add/Remove).")]),t._v(" "),a("p",[t._v("[[ TODO: instead of leftmost non-empty leaf, start with "),a("code",[t._v("triggering block time ``mod`` leaf_count")]),t._v(" closest non-empty to the right circulating to 0 ? ]]")]),t._v(" "),a("p",[t._v("(It should use the triggering block's number as AAD.)\nIf there are only Add proposals (post-genesis/group creation), populating the path can be omitted.")]),t._v(" "),a("p",[t._v("If CommitChangeTx is not received in a block with time less the triggering block's time + timeout,\nOR received CommitChangeTx was invalid;")]),t._v(" "),a("p",[t._v("node's TDBE corresponding to the next leftmost non-empty leaf should generate and broadcast "),a("code",[t._v("CommitChangeTx")]),t._v(" -- it should include\na Remove proposal for the previous node(s) (that failed to submit in time or submitted invalid "),a("code",[t._v("CommitChangeTx")]),t._v(';\nit should be indicated in timeout-committed block\n);\nand include any additional proposals (if any) since the original triggering block;\n(it should take the latest "timeout" block\'s number as AAD.)')]),t._v(" "),a("p",[t._v("Commit (in "),a("code",[t._v("CommitChangeTx")]),t._v(" / "),a("code",[t._v("SelfUpdateProposal")]),t._v(") should be applied after NACK timeout.")]),t._v(" "),a("h6",{attrs:{id:"nack"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nack"}},[t._v("#")]),t._v(" NACK")]),t._v(" "),a("p",[t._v("If the receiver of the "),a("code",[t._v("HPKECiphertext")]),t._v(" (Welcome message or DirectPath) cannot process it\n/ it fails (e.g. the encrypted secret does not match the outside public key),\nthey generate and broadcast a message that\nreveals "),a("code",[t._v("dh")]),t._v(" value and provides a proof "),a("code",[t._v("DLEQ(dh/kem_output == node_hpke_public_key/group_point)")]),t._v("\n(ref: https://blog.cloudflare.com/privacy-pass-the-math/).")]),t._v(" "),a("p",[t._v("If NACK is valid and submitted in time, the Commit-containing message should be considered as invalid\n(even though the corresponding TX was assumed as valid before) -- the punishment logic should be applied\nto the related message submitter;\nthe next node's TDBE (next non-empty leaf) should generate and broadcast "),a("code",[t._v("CommitChangeTx")]),t._v('\nand include Remove proposals as with the "commit timeout" case.')]),t._v(" "),a("h6",{attrs:{id:"updates"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#updates"}},[t._v("#")]),t._v(" Updates")]),t._v(" "),a("p",[t._v("After 1/3 of keypackage's lifetime is over, TDBE is allowed to generate and broadcast "),a("code",[t._v("SelfUpdateProposal")])]),t._v(" "),a("p",[t._v("-- it may happen that there's another committed "),a("code",[t._v("SelfUpdateProposal")]),t._v(" (from a different sender) or "),a("code",[t._v("CommitChangeTx")]),t._v(",\nwhich makes TDBE's original "),a("code",[t._v("SelfUpdateProposal")]),t._v(" -- in which case, it should re-generate and retry.")]),t._v(" "),a("h6",{attrs:{id:"new-obfuscation-key"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#new-obfuscation-key"}},[t._v("#")]),t._v(" new obfuscation key")]),t._v(" "),a("p",[t._v("Once the Commit is applied (or state is reconstructed from Welcome), TDBE should generate a new obfuscation key as:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('new_key = MLS-Exporter(\n    Label="Crypto.com Chain tx validation " + block number where CommitChangeTx is included,\n    Context=(that updated group\'s context),\n    length=(AES_128_GCM_SIV key length)\n)\n')])])]),a("p",[t._v("and it should push it over mutually attested TLS to TVE.\nTVE should delete old key after being pushed the new key.")]),t._v(" "),a("p",[t._v("As with https://github.com/mlswg/mls-protocol/blob/master/draft-ietf-mls-protocol.md#deletion-schedule")]),t._v(" "),a("p",[t._v("TDBE should delete the secrets + exported key after it's been pushed to TVE.")]),t._v(" "),a("h5",{attrs:{id:"abci-processing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abci-processing"}},[t._v("#")]),t._v(" abci processing")]),t._v(" "),a("p",[t._v("In MLS Architecture terminology:")]),t._v(" "),a("ul",[a("li",[t._v("Tendermint serves as Delivery Service (DS)")]),t._v(" "),a("li",[t._v("IAS/DCAP/... + Tendermint (staking states) serve as Authentication Service (AS)")])]),t._v(" "),a("p",[t._v("As such, abci app (chain-abci) needs to have some understanding of the logic of "),a("code",[t._v("MLSHandshake")]),t._v(" transaction types.")]),t._v(" "),a("p",[t._v("Notably, it needs:")]),t._v(" "),a("ul",[a("li",[t._v("to keep track of (MLS) Leaf"),a("code",[t._v("<->")]),t._v("staking address mapping in order to execute corresponding updates on stake")]),t._v(" "),a("li",[t._v("to keep track of keypackage lifetimes -- to limit frequency / know when "),a("code",[t._v("SelfUpdateProposal")]),t._v(" are valid; for validators whose corresponding keypackage expires,\nthey should be removed from the validator set (similar to liveness fault handling)")]),t._v(" "),a("li",[t._v("to keep track if valid "),a("code",[t._v("CommitChangeTx")]),t._v(" was received in time -- invalid one receive similar treatment as byzantine faults (removal from validator set if a validator + slash)")]),t._v(" "),a("li",[t._v("to keep track if valid "),a("code",[t._v("NACK")]),t._v(' was received after a "valid" '),a("code",[t._v("CommitChangeTx")]),t._v(" -- NACK invalidating "),a("code",[t._v("CommitChangeTx")]),t._v(" should treat the "),a("code",[t._v("CommitChangeTx")]),t._v(" similar to byzantine faults")]),t._v(" "),a("li",[t._v("after "),a("code",[t._v("CommitChangeTx")]),t._v(" -- after block commit and NACK timeout, enquire TVE if it was pushed a new key;\nif not, it is a local node problem (e.g. no running TDBE) -- TODO: block consensus state machine or shutdown?")])]),t._v(" "),a("p",[t._v("[[ OPEN ISSUE:\nhttps://github.com/mlswg/mls-protocol/issues/21")]),t._v(" "),a("p",[t._v("update the NACK solution here with the official one when it is drafted in the protocol spec\n]]")])])}),[],!1,null,null,null);e.default=n.exports}}]);